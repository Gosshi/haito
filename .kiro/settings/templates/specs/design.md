# 設計ドキュメントテンプレート

---
**目的**: 異なる実装者間で実装の一貫性を確保し、解釈のずれを防ぐのに十分な詳細を提供する。

**アプローチ**:
- 実装決定に直接影響を与える必須セクションを含める
- 実装エラーを防ぐために重要でない限り、オプションセクションは省略する
- 機能の複雑さに合わせた詳細レベル
- 長い散文よりも図表やテーブルを使用する

**警告**: 1000行に近づくと、機能の複雑さが過度であり、設計の簡素化が必要な可能性がある。
---

> セクションは、明確性が向上する場合に並べ替えることができる（例: 要件トレーサビリティを前に出す、データモデルをアーキテクチャの近くに移動する）。各セクション内では、**サマリー → スコープ → 決定 → 影響/リスク**のフローを維持し、レビュアーが一貫してスキャンできるようにする。

## 概要
最大2〜3段落
**目的**: この機能は[特定の価値]を[対象ユーザー]に提供する。
**ユーザー**: [対象ユーザーグループ]がこれを[特定のワークフロー]に使用する。
**影響**（該当する場合）: [特定の変更]により現在の[システム状態]を変更する。


### 目標
- 主要な目的1
- 主要な目的2
- 成功基準

### 非目標
- 明示的に除外される機能
- 現在のスコープ外の将来の検討事項
- 延期された統合ポイント

## アーキテクチャ

> 詳細な発見ノートは背景のためにのみ`research.md`を参照する。すべての決定とコントラクトをここにキャプチャして、レビュアー向けに自己完結したdesign.mdを維持する。
> 重要な決定はテキストでキャプチャし、図には構造的詳細を持たせる—同じ情報を散文で繰り返さない。

### 既存アーキテクチャ分析（該当する場合）
既存システムを修正する場合:
- 現在のアーキテクチャパターンと制約
- 尊重すべき既存のドメイン境界
- 維持すべき統合ポイント
- 対処または回避する技術的負債

### アーキテクチャパターンと境界マップ
**推奨**: 選択したアーキテクチャパターンとシステム境界を示すMermaid図を含める（複雑な機能には必須、単純な追加ではオプション）

**アーキテクチャ統合**:
- 選択したパターン: [名前と簡潔な根拠]
- ドメイン/機能境界: [競合を避けるための責任の分離方法]
- 保持する既存パターン: [主要なパターンをリスト]
- 新しいコンポーネントの根拠: [各々が必要な理由]
- ステアリング準拠: [維持する原則]

### 技術スタック

| レイヤー | 選択 / バージョン | 機能での役割 | 注記 |
|----------|------------------|-------------|------|
| フロントエンド / CLI | | | |
| バックエンド / サービス | | | |
| データ / ストレージ | | | |
| メッセージング / イベント | | | |
| インフラ / ランタイム | | | |

> 根拠は簡潔に保ち、より深い内容（トレードオフ、ベンチマーク）が必要な場合は、短いサマリーとサポートリファレンスセクションおよび`research.md`への生の調査ノートへのポインタを追加する。

## システムフロー

非自明なフローを説明するために必要な図のみを提供する。プレーンなMermaid構文を使用する。一般的なパターン:
- シーケンス（マルチパーティインタラクション）
- プロセス / 状態（分岐ロジックまたはライフサイクル）
- データ / イベントフロー（パイプライン、非同期メッセージング）

単純なCRUD変更の場合はこのセクション全体をスキップする。
> 各ステップを再述するのではなく、図の後にフローレベルの決定（例: ゲート条件、リトライ）を簡潔に説明する。

## 要件トレーサビリティ

要件が複数のドメインにまたがる複雑またはコンプライアンス重要な機能にはこのセクションを使用する。単純な1:1マッピングはコンポーネントサマリーテーブルに依存できる。

各要件ID（例: `2.1`）をそれを実現する設計要素にマッピングする。

| 要件 | 概要 | コンポーネント | インターフェース | フロー |
|------|------|--------------|----------------|-------|
| 1.1 | | | | |
| 1.2 | | | | |

> 単一のコンポーネントが横断的な懸念なしに単一の要件を満たす場合のみ、このセクションを省略する。

## コンポーネントとインターフェース

コンポーネントごとの詳細に入る前のクイックリファレンスを提供する。

- サマリーはテーブルまたはコンパクトなリストにできる。テーブルの例:
  | コンポーネント | ドメイン/レイヤー | 意図 | 要件カバレッジ | 主要な依存関係 (P0/P1) | コントラクト |
  |--------------|-----------------|------|--------------|---------------------|------------|
  | ExampleComponent | UI | XYZを表示する | 1, 2 | GameProvider (P0), MapPanel (P1) | Service, State |
- 新しい境界を導入するコンポーネント（例: ロジックフック、外部統合、永続化）のみがフル詳細ブロックを必要とする。単純なプレゼンテーションコンポーネントはサマリー行と短い実装ノートに依存できる。

詳細ブロックをドメインまたはアーキテクチャレイヤーでグループ化する。各詳細コンポーネントについて、要件IDを`2.1, 2.3`としてリストする（「要件」を省略）。複数のUIコンポーネントが同じコントラクトを共有する場合、コードブロックを複製する代わりにベースインターフェース/props定義を参照する。

### [ドメイン / レイヤー]

#### [コンポーネント名]

| フィールド | 詳細 |
|----------|------|
| 意図 | 責任の1行説明 |
| 要件 | 2.1, 2.3 |
| オーナー / レビュアー | （オプション） |

**責任と制約**
- 主要な責任
- ドメイン境界とトランザクションスコープ
- データオーナーシップ / 不変条件

**依存関係**
- インバウンド: コンポーネント/サービス名 — 目的（重要度）
- アウトバウンド: コンポーネント/サービス名 — 目的（重要度）
- 外部: サービス/ライブラリ — 目的（重要度）

外部依存関係の発見をここにサマリーする。詳細な調査（APIシグネチャ、レート制限、マイグレーションノート）は`research.md`に記載。

**コントラクト**: Service [ ] / API [ ] / Event [ ] / Batch [ ] / State [ ]  ← 適用されるもののみチェック。

##### サービスインターフェース
```typescript
interface [ComponentName]Service {
  methodName(input: InputType): Result<OutputType, ErrorType>;
}
```
- 事前条件:
- 事後条件:
- 不変条件:

##### APIコントラクト
| メソッド | エンドポイント | リクエスト | レスポンス | エラー |
|---------|--------------|----------|---------|-------|
| POST | /api/resource | CreateRequest | Resource | 400, 409, 500 |

##### イベントコントラクト
- 発行イベント:
- 購読イベント:
- 順序 / 配信保証:

##### バッチ / ジョブコントラクト
- トリガー:
- 入力 / 検証:
- 出力 / 宛先:
- 冪等性とリカバリー:

##### 状態管理
- 状態モデル:
- 永続化と一貫性:
- 同時実行戦略:

**実装ノート**
- 統合:
- 検証:
- リスク:

## データモデル

この機能で変更されるデータ領域の部分に焦点を当てる。

### ドメインモデル
- 集約とトランザクション境界
- エンティティ、値オブジェクト、ドメインイベント
- ビジネスルールと不変条件
- 複雑な関係にはオプションでMermaid図

### 論理データモデル

**構造定義**:
- エンティティ関係とカーディナリティ
- 属性とその型
- ナチュラルキーと識別子
- 参照整合性ルール

**一貫性と整合性**:
- トランザクション境界
- カスケードルール
- 時間的側面（バージョニング、監査）

### 物理データモデル
**含める場合**: 実装が特定のストレージ設計決定を必要とする場合

**リレーショナルデータベースの場合**:
- データ型を含むテーブル定義
- プライマリ/外部キーと制約
- インデックスとパフォーマンス最適化
- スケール用のパーティショニング戦略

**ドキュメントストアの場合**:
- コレクション構造
- 埋め込み vs 参照の決定
- シャーディングキー設計
- インデックス定義

**イベントストアの場合**:
- イベントスキーマ定義
- ストリーム集約戦略
- スナップショットポリシー
- プロジェクション定義

**キーバリュー/ワイドカラムストアの場合**:
- キー設計パターン
- カラムファミリーまたは値構造
- TTLとコンパクション戦略

### データコントラクトと統合

**APIデータ転送**
- リクエスト/レスポンススキーマ
- 検証ルール
- シリアライゼーションフォーマット（JSON、Protobufなど）

**イベントスキーマ**
- 発行されるイベント構造
- スキーマバージョニング戦略
- 後方/前方互換性ルール

**クロスサービスデータ管理**
- 分散トランザクションパターン（Saga、2PC）
- データ同期戦略
- 結果整合性の処理

この機能に関連しないサブセクションはスキップする。

## エラーハンドリング

### エラー戦略
各エラータイプに対する具体的なエラーハンドリングパターンとリカバリーメカニズム。

### エラーカテゴリと応答
**ユーザーエラー** (4xx): 無効な入力 → フィールドレベル検証; 未認証 → 認証ガイダンス; 見つからない → ナビゲーションヘルプ
**システムエラー** (5xx): インフラ障害 → グレースフルデグラデーション; タイムアウト → サーキットブレーカー; リソース枯渇 → レート制限
**ビジネスロジックエラー** (422): ルール違反 → 条件説明; 状態競合 → 遷移ガイダンス

**プロセスフロー可視化**（複雑なビジネスロジックがある場合）:
ビジネスワークフローを伴う複雑なエラーシナリオにのみMermaidフローチャートを含める。

### モニタリング
エラー追跡、ロギング、ヘルスモニタリングの実装。

## テスト戦略

### デフォルトセクション（ドメインに合わせて名前/セクションを調整）
- ユニットテスト: コア機能/モジュールから3〜5項目（例: 認証メソッド、サブスクリプションロジック）
- 統合テスト: 3〜5のクロスコンポーネントフロー（例: Webhookハンドリング、通知）
- E2E/UIテスト（該当する場合）: 3〜5の重要なユーザーパス（例: フォーム、ダッシュボード）
- パフォーマンス/負荷（該当する場合）: 3〜4項目（例: 同時実行、高ボリューム操作）

## オプションセクション（関連する場合に含める）

### セキュリティ考慮事項
_認証、機密データ、外部統合、またはユーザー権限を扱う機能にはこのセクションを使用する。この機能に固有の決定のみをキャプチャし、基本的なコントロールはステアリングドキュメントに委ねる。_
- 脅威モデリング、セキュリティコントロール、コンプライアンス要件
- 認証と認可パターン
- データ保護とプライバシー考慮事項

### パフォーマンスとスケーラビリティ
_パフォーマンス目標、高負荷、またはスケーリング懸念がある場合にこのセクションを使用する。機能固有の目標またはトレードオフのみを記録し、一般的なプラクティスについてはステアリングドキュメントに依存する。_
- ターゲットメトリクスと測定戦略
- スケーリングアプローチ（水平/垂直）
- キャッシング戦略と最適化技術

### マイグレーション戦略
スキーマ/データ移動が必要な場合、マイグレーションフェーズを示すMermaidフローチャートを含める。
- フェーズ分割、ロールバックトリガー、検証チェックポイント

## サポートリファレンス（オプション）
- このセクションは、メインボディに情報を保持すると可読性が損なわれる場合にのみ作成する（例: 非常に長いTypeScript定義、ベンダーオプションマトリックス、網羅的なスキーマテーブル）。設計が自己完結するように、意思決定コンテキストはメインセクションに保持する。
- 大きなスニペットをインライン化する代わりに、メインテキストからサポートリファレンスへリンクする。
- 背景調査ノートと比較は引き続き`research.md`に記載するが、その結論はメイン設計にサマリーする必要がある。
