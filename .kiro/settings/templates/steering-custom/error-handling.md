# エラーハンドリング標準

[目的: エラーの分類、形状、伝播、ロギング、監視の方法を統一]

## 哲学
- 可能な場合は早期失敗; システム境界でグレースフルにデグレード
- スタック全体で一貫したエラー形状（人間と機械の両方で読み取り可能）
- 既知のエラーはソースに近いところで処理; 未知のエラーはグローバルハンドラーに表面化

## 分類（ソースでハンドリングを決定）
- クライアント: 入力/検証/ユーザーアクションの問題 → 4xx
- サーバー: システム障害/予期しない例外 → 5xx
- ビジネス: ルール/状態違反 → 4xx（例: 409）
- 外部: サードパーティ/ネットワーク障害 → コンテキスト付きで5xxまたは4xxにマッピング

## エラー形状（単一の正規フォーマット）
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "人間可読メッセージ",
    "requestId": "trace-id",
    "timestamp": "ISO-8601"
  }
}
```
原則: 安定したコード列挙、シークレットなし、トレース情報を含む。

## 伝播（どこで変換するか）
- APIレイヤー: ドメインエラー → HTTPステータス + 正規ボディに変換
- サービスレイヤー: 型付きビジネスエラーをスロー、文字列型エラーを避ける
- データ/外部レイヤー: プロバイダーエラーを安全で実行可能なコードでラップ
- 未知のエラー: グローバルハンドラーにバブル → 500 + 汎用メッセージ

パターン例:
```typescript
try { return await useCase(); }
catch (e) {
  if (e instanceof BusinessError) return respondMapped(e);
  logError(e); return respondInternal();
}
```

## ロギング（ノイズよりコンテキスト）
ログする: 操作、userId（利用可能な場合）、コード、メッセージ、スタック、requestId、最小限のコンテキスト。
ログしない: パスワード、トークン、シークレット、完全なPII、機密データを含む完全なボディ。
レベル: ERROR（失敗）、WARN（回復可能/エッジ）、INFO（主要イベント）、DEBUG（診断）。

## リトライ（安全な場合のみ）
リトライする場合: ネットワーク/タイムアウト/一時的な5xx かつ 操作が冪等。
リトライしない場合: 4xx、ビジネスエラー、非冪等フロー。
戦略: 指数バックオフ + ジッター、上限付き試行; 冪等性キーが必要。

## モニタリングとヘルス
追跡: コード/カテゴリごとのエラーレート、レイテンシ、飽和度; スパイク/SLI違反でアラート。
ヘルスを公開: `/health`（ライブ）、`/health/ready`（レディ）。エラーをトレースにリンク。

---
_パターンと決定に焦点を当てる。実装詳細や網羅的リストなし。_
