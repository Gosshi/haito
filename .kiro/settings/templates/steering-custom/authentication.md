# 認証・認可標準

[目的: 認証モデル、トークン/セッションライフサイクル、権限チェック、セキュリティを統一する]

## 哲学
- 明確な分離: 認証（誰か）vs 認可（何ができるか）
- デフォルトでセキュア: 最小権限、失敗時は閉じる、短命トークン
- UX考慮: リスクが高いところに摩擦を、そうでなければスムーズに

## 認証

### 方式（選択 + 根拠）
- オプション: JWT、セッション、OAuth2、ハイブリッド
- 選択: [私たちの方式] 理由は[根拠]

### フロー（ハイレベル）
```
1) ユーザーが身元を証明（認証情報またはプロバイダー）
2) サーバーが検証しトークン/セッションを発行
3) クライアントがリクエストごとにトークンを送信
4) サーバーがトークンを検証して続行
```

### トークン/セッションライフサイクル
- 保存: httpOnlyクッキーまたはAuthorizationヘッダー
- 有効期限: 短命アクセス、長めのリフレッシュ（使用する場合）
- リフレッシュ: トークンをローテーション; 失効を尊重
- 失効: ログアウト/侵害時にブラックリスト/ローテーション

### セキュリティパターン
- TLSを強制; 可能な限りJSにトークンを公開しない
- トークンをaudience/issuerにバインド; 最小限のクレームを含める
- 機密操作にはデバイスバインディングとIP/リスクチェックを検討

## 認可

### 権限モデル
- 選択: RBAC / ABAC / オーナーシップベース / ハイブリッド
- ロール/属性を中央で定義; コードベース全体でハードコードを避ける

### チェック（どこで強制するか）
- ルート/ミドルウェア: 粗いゲート
- ドメイン/サービス: 詳細な決定
- UI: 条件付きレンダリング（セキュリティ依存なし）

パターン例:
```typescript
requirePermission('resource:action'); // ルート
if (!user.can('resource:action')) throw ForbiddenError(); // ドメイン
```

### オーナーシップ
- パターン: オーナーまたは特権ロールが操作可能
- 変更前にエンティティ境界で確認

## パスワードとMFA
- パスワード: 強力なポリシー、ハッシュ化（bcrypt/argon2）、平文禁止
- リセット: 時間制限トークン、単一使用、ユーザー通知
- MFA: リスクの高い操作にステップアップ（ポリシー駆動）

## API間認証
- APIキーまたはOAuthクライアントクレデンシャルを使用
- キーを最小限にスコープ; ローテーションと利用監査
- IDごとにレート制限（ユーザー/キー）

---
_パターンと決定に焦点を当てる。ライブラリ固有のコードなし。_
