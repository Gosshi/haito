---
description: 仕様の包括的な技術設計を作成する
allowed-tools: Bash, Glob, Grep, LS, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
argument-hint: <feature-name> [-y]
---

# 技術設計ジェネレーター

<background_information>
- **ミッション**: 要件（WHAT）をアーキテクチャ設計（HOW）に変換する包括的な技術設計ドキュメントを生成する
- **成功基準**:
  - すべての要件が明確なインターフェースを持つ技術コンポーネントにマッピングされている
  - 適切なアーキテクチャディスカバリーと調査が完了している
  - 設計がステアリングコンテキストと既存パターンに整合している
  - 複雑なアーキテクチャには視覚的な図が含まれている
</background_information>

<instructions>
## コアタスク
承認済み要件に基づいて機能 **$1** の技術設計ドキュメントを生成する。

## 実行ステップ

### ステップ1: コンテキストのロード

**必要なコンテキストをすべて読み込む**:
- `.kiro/specs/$1/spec.json`、`requirements.md`、`design.md`（存在する場合）
- **完全なプロジェクトメモリのための`.kiro/steering/`ディレクトリ全体**
- `.kiro/settings/templates/specs/design.md`でドキュメント構造を確認
- `.kiro/settings/rules/design-principles.md`で設計原則を確認
- `.kiro/settings/templates/specs/research.md`でディスカバリーログ構造を確認

**要件承認の検証**:
- `-y`フラグが提供された場合（$2 == "-y"）: spec.jsonで要件を自動承認
- それ以外: 承認ステータスを確認（未承認の場合は停止、セーフティ＆フォールバックを参照）

### ステップ2: ディスカバリーと分析

**重要: このフェーズは設計が完全で正確な情報に基づいていることを保証する。**

1. **機能タイプを分類**:
   - **新機能**（グリーンフィールド）→ フルディスカバリーが必要
   - **拡張**（既存システム）→ 統合にフォーカスしたディスカバリー
   - **単純追加**（CRUD/UI）→ 最小限または不要のディスカバリー
   - **複雑な統合** → 包括的な分析が必要

2. **適切なディスカバリープロセスを実行**:

   **複雑/新機能の場合**:
   - `.kiro/settings/rules/design-discovery-full.md`を読んで実行
   - WebSearch/WebFetchを使用して徹底的な調査を実施:
     - 最新のアーキテクチャパターンとベストプラクティス
     - 外部依存関係の検証（API、ライブラリ、バージョン、互換性）
     - 公式ドキュメント、マイグレーションガイド、既知の問題
     - パフォーマンスベンチマークとセキュリティ考慮事項

   **拡張の場合**:
   - `.kiro/settings/rules/design-discovery-light.md`を読んで実行
   - 統合ポイント、既存パターン、互換性にフォーカス
   - Grepを使用して既存コードベースのパターンを分析

   **単純追加の場合**:
   - 正式なディスカバリーをスキップ、クイックパターンチェックのみ

3. **ステップ3のためにディスカバリーの発見事項を保持**:
- 外部APIコントラクトと制約
- 根拠付きの技術決定
- 従うまたは拡張する既存パターン
- 統合ポイントと依存関係
- 特定されたリスクと軽減戦略
- 潜在的なアーキテクチャパターンと境界オプション（詳細を`research.md`に記録）
- 将来のタスクのための並列化考慮事項（依存関係を`research.md`にキャプチャ）

4. **調査ログに発見事項を永続化**:
- 共有テンプレートを使用して`.kiro/specs/$1/research.md`を作成または更新
- ディスカバリースコープと主要な発見事項を要約（サマリーセクション）
- ソースと影響を含む調査ログトピックに調査を記録
- テンプレートセクションを使用してアーキテクチャパターン評価、設計決定、リスクを文書化
- `research.md`の記述または更新時はspec.jsonで指定された言語を使用

### ステップ3: 設計ドキュメントの生成

1. **設計テンプレートとルールをロード**:
- 構造のために`.kiro/settings/templates/specs/design.md`を読む
- 原則のために`.kiro/settings/rules/design-principles.md`を読む

2. **設計ドキュメントを生成**:
- **specs/design.mdテンプレートの構造と生成指示に厳密に従う**
- **すべてのディスカバリーの発見事項を統合**: 調査された情報（API、パターン、技術）をコンポーネント定義、アーキテクチャ決定、統合ポイント全体で使用
- ステップ1で既存のdesign.mdが見つかった場合、参照コンテキストとして使用（マージモード）
- 設計ルールを適用: 型安全性、ビジュアルコミュニケーション、フォーマルトーン
- spec.jsonで指定された言語を使用
- セクションが更新された見出し（「アーキテクチャパターンと境界マップ」、「技術スタックと整合性」、「コンポーネントとインターフェースコントラクト」）を反映し、`research.md`からのサポート詳細を参照していることを確認

3. **spec.jsonのメタデータを更新**:
- `phase: "design-generated"`を設定
- `approvals.design.generated: true, approved: false`を設定
- `approvals.requirements.approved: true`を設定
- `updated_at`タイムスタンプを更新

## 重要な制約
 - **型安全性**:
   - プロジェクトの技術スタックに沿った強い型付けを強制する
   - 静的型付け言語では、明示的な型/インターフェースを定義し、安全でないキャストを避ける
   - TypeScriptでは`any`を使用しない; 正確な型とジェネリクスを優先
   - 動的型付け言語では、利用可能な型ヒント/アノテーションを提供し（例: Python型ヒント）、境界で入力を検証
   - クロスコンポーネントの型安全性を確保するために、パブリックインターフェースとコントラクトを明確に文書化
- **最新情報**: 外部依存関係とベストプラクティスにはWebSearch/WebFetchを使用
- **ステアリング整合性**: ステアリングコンテキストからの既存アーキテクチャパターンを尊重
- **テンプレート準拠**: specs/design.mdテンプレートの構造と生成指示に厳密に従う
- **設計フォーカス**: アーキテクチャとインターフェースのみ、実装コードなし
- **要件トレーサビリティID**: requirements.mdで定義された数値要件IDのみを使用（例: "1.1", "1.2", "3.1", "3.3"）。新しいIDを作成したりアルファベットラベルを使用しない
</instructions>

## ツールガイダンス
- **最初に読む**: アクションを起こす前にすべてのコンテキストをロード（specs、steering、templates、rules）
- **不確かな場合は調査**: 外部依存関係、API、最新のベストプラクティスにはWebSearch/WebFetchを使用
- **既存コードを分析**: Grepを使用してコードベースのパターンと統合ポイントを見つける
- **最後に書く**: すべての調査と分析が完了した後にのみdesign.mdを生成

## 出力説明

**コマンド実行出力**（design.mdの内容とは別）:

spec.jsonで指定された言語で簡潔なサマリーを提供:

1. **ステータス**: `.kiro/specs/$1/design.md`に設計ドキュメントが生成されたことを確認
2. **ディスカバリータイプ**: どのディスカバリープロセスが実行されたか（full/light/minimal）
3. **主要な発見事項**: 設計を形成した`research.md`からの2〜3の重要な洞察
4. **次のアクション**: 承認ワークフローガイダンス（セーフティ＆フォールバックを参照）
5. **調査ログ**: `research.md`が最新の決定で更新されたことを確認

**フォーマット**: 簡潔なMarkdown（200語以下）- これはコマンド出力であり、設計ドキュメント自体ではない

**注記**: 実際の設計ドキュメントは`.kiro/settings/templates/specs/design.md`の構造に従う。

## セーフティ＆フォールバック

### エラーシナリオ

**要件が承認されていない**:
- **実行停止**: 承認された要件なしには進められない
- **ユーザーメッセージ**: 「要件がまだ承認されていません。設計生成前に承認が必要です。」
- **推奨アクション**: 「`/kiro:spec-design $1 -y`を実行して要件を自動承認して続行してください」

**要件が見つからない**:
- **実行停止**: 要件ドキュメントが存在する必要がある
- **ユーザーメッセージ**: 「`.kiro/specs/$1/requirements.md`にrequirements.mdが見つかりません」
- **推奨アクション**: 「最初に`/kiro:spec-requirements $1`を実行して要件を生成してください」

**テンプレートが見つからない**:
- **ユーザーメッセージ**: 「`.kiro/settings/templates/specs/design.md`にテンプレートファイルが見つかりません」
- **推奨アクション**: 「リポジトリのセットアップを確認するか、テンプレートファイルを復元してください」
- **フォールバック**: 警告付きでインライン基本構造を使用

**ステアリングコンテキストが見つからない**:
- **警告**: 「ステアリングディレクトリが空または見つかりません - 設計がプロジェクト標準に整合しない可能性があります」
- **続行**: 生成を続行するが、出力に制限を記載

**ディスカバリー複雑さが不明**:
- **デフォルト**: フルディスカバリープロセスを使用（`.kiro/settings/rules/design-discovery-full.md`）
- **根拠**: 重要なコンテキストを見逃すよりも調査過多の方が良い
- **無効な要件ID**:
  - **実行停止**: requirements.mdに数値IDがない、または非数値の見出し（例: 「要件A」）を使用している場合、停止してユーザーにrequirements.mdを続行前に修正するよう指示する

### 次フェーズ: タスク生成

**設計が承認された場合**:
- `.kiro/specs/$1/design.md`で生成された設計を確認
- **オプション**: インタラクティブな品質レビューのために`/kiro:validate-design $1`を実行
- その後`/kiro:spec-tasks $1 -y`で実装タスクを生成

**修正が必要な場合**:
- フィードバックを提供し、`/kiro:spec-design $1`を再実行
- 既存の設計が参照として使用される（マージモード）

**注記**: タスク生成に進む前に設計の承認は必須。

think hard
